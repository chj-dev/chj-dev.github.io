---
title: 8 생산자 소비자 문제1
date: 2024-10-27 18:23:00 +0900
categories: [Study, Java-advanced1]
tags: [study, java, thread, adv1]
pin: true
---

## 스터디 git 주소
<hr />

- <https://github.com/chj-dev/java-adv1>


## 생산자 소비자 문제(producer-consumer problem)
<hr />

- 멀티 스레드 프로그래밍에서 자주 등장하는 동시성 문제 중 하나.
- 여러 스레드가 동시에 데이터를 생산하고 소비하는 상황.
- **한정된 버퍼 문제(bounded-buffer problem)** 이라고도 불린다.

### 개념

- **생산자(Producer)**: 데이터를 생성하는 역할.
  - ex. 파일에서 데이터를 읽어오거나 네트워크에서 데이터를 받아오는 스레드.
- **소비자(Consumer)**: 생성된 데이터를 사용하는 역할.
  - ex. 데이터를 처리하거나 저장하는 스레드.
- **버퍼(Buffer)**: 생산자가 생성한 데이터를 일시적으로 저장하는 공간. 한정된 크기를 가지며, 해당 버퍼를 통해 생산자와 소비자가 데이터를 주고받는다.

### 무엇이 문제일까?

- **생산자가 너무 빠를 때**: 버퍼가 가득 차서 데이터를 넣을 수 없을 때까지 생산자가 데이터를 생성할 때, 버퍼가 빌 때까지 기다려야 한다.
- **소비자가 너무 빠를 때**: 버퍼가 비어서 데이터를 소비할 수 없을 때까지 소비자가 데이터를 처리할 때, 버퍼에 데이터가 생길 때까지 기다려야 한다.

### sleep(millis) 를 사용하여 기다리면?

- 락(lock) 을 가지고 기다리는 것이기 때문에, 결국 임계영역 안에서 코드를 수행해야 하는 다른 스레드들은 영원히 락이 반환되길 기다리는 수밖에 없다.
- 이렇게 되면 락을 가진 스레드는 `TIMED_WAITING`, 나머지 스레드는 `BLOCKED` 상태가 지속된다.

> 락을 가지고 기다려서 문제가 되는 것이기 때문에, 락을 양보하고 기다리면 문제가 해결될 것이다.
> 자바의 Object.wait(), Object.notify() 를 사용하면 락을 양보하고 대기할 수 있다.
{: .prompt-info }

## Object - wait, notify

- Object 는 모든 자바 객체의 부모이기 때문에 wait() 과 notify() 메서드를 사용할 수 있다.
- `Object.wait()`
  - 현재 스레드가 가진 락을 반납하고 대기(WAITING)한다.
  - 현재 스레드가 synchronized 블록이나 락을 소유하고 있을때만 호출할 수 있다.
  - 대기 상태로 전환된 스레드는 다시 스레드가 notify() 또는 notifyAll() 을 호출할 때까지 대기상태를 유지한다.
- `Object.notify()`
  - 대기 중인 스레드 중 하나를 깨운다. 대기 중인 스레드가 여러 개이면, 어떤 스레드가 깨어날지 알 수 없다.
  - wait() 과 마찬가지로 현재 스레드가 synchronized 블록이나 메서드 내에서 호출되어야 한다.
- `Object.notifyAll()`
  - 대기 중인 모든 스레드를 깨운다.
  - notify() 와 마찬가지로 현재 스레드가 synchronized 블록이나 메서드 내에서 호출되어야 한다.

### 대기 집합(wait set)

- wait() 호출을 통해 대기 상태에 들어간 스레드를 관리하는 것을 대기 집합(wait set) 이라 한다.
- 모든 객체는 각자의 대기 집합을 가지고 있다. 이는 락(모니터 락) 과 한 쌍이다.

### 하지만 위 메서드를 사용하는 방법도 한계가 있다.

- notify() 를 사용하면 대기 중인 스레드 중 어떤 스레드가 깨어날 지 알 수 없기 때문에, 
 **생산이 필요한 상황에 소비자 스레드가 깨어날 수도 있고, 반대로 소비자 필요한 상황에 생산자 스레드가 깨어날 수도 있다.**
 물론 성능 상으로 문제가 생길 수 있을 뿐 결과는 동일할 것이다.
- notifyAll() 도 모든 스레드를 깨우는 것이기 때문에, 마찬가지로 성능 상으로 문제가 생길 수 있을 뿐 결과는 동일할 것이다.


- notify() 는 어떤 스레드가 깨어날 지 알 수 없기 때문에 **스레드 기아(thread starvation)** 문제가 발생할 수도 있다.

### 어떻게 해결해야 할까?

> 다음 정리에...


## 참고자료
<hr />

[김영한의 실전 자바 - 고급 1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)
