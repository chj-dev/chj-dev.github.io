---
title: 5 메모리 가시성
date: 2024-09-24 22:27:00 +0900
categories: [Study, Java-advanced1]
tags: [study, java, thread, adv1]
pin: true
---

## 스터디 git 주소
<hr />

- <https://github.com/chj-dev/java-adv1>

## 메모리 가시성 (Memory Visibility)
<hr />

- 멀티스레드는 한번에 여러 작업을 할 수 있다는 점에서 마냥 좋아보이지만 몇가지 문제가 있다.
- 멀티스레드 환경에서, A 스레드가 변경한 값이 B 스레드에 언제 반영되는 지에 대한 문제를 메모리 가시성이라 한다.

### 왜 즉시 반영되지 않을까?

- **CPU 는 처리 성능을 개선하기 위해** `캐시 메모리` **를 사용한다.**

> 캐시 메모리: 메인 메모리보다 CPU 와 가깝고, 속도도 빨라서 CPU의 빠른 연산을 따라갈 수 있다.
> CPU 는 대부분 코어 단위로 캐시 메모리를 가지고 있다.
{: .prompt-info }

- 위를 이유로, CPU 는 값을 먼저 캐시 메모리에 불러온다. 이때, A 스레드와 B 스레드가 사용하는 변수가 각각의 캐시 메모리에 보관된다.
- 만약 A 스레드에서 변수 값을 변경하면, 이 변경된 값은 캐시 메모리에만 변경이 된다. 메인 메모리까지 값이 즉시 변경되지 않는다.

> 메인 메모리까지 변경되지 않아 B 스레드는 변수 값이 변경되었는지 알 수 없다.
{: .prompt-info }

### 계속 기다린다면 언제 반영될까?

- 알 수 없다. CPU 설계 방식과 종류에 따라 다르다.
- 그리고 메인 메모리에 반영이 된다 하여도, 다시 A 스레드의 캐시 메모리에 불러와야 하는 작업이 기다리고 있다.
- 컨텍스트 스위칭이 되면 캐시 메모리가 갱신되면서 값이 변경될 수 있는데, 반드시 갱신을 보장하지는 않는다.

### 즉시 반영되게 하려면?

- volatile 키워드를 사용하는 방법이 있다.

> volatile: 변수 값을 읽거나 쓸 때, 메인 메모리에 직접 접근하게 한다. 
> 성능을 약간 포기하는 대신, 모든 스레드에서 같은 시점에 같은 값을 볼 수 있다.
{: .prompt-info }

- 스레드 동기화 기법(synchronized, ReentrantLock)을 사용하는 방법이 있다.

> 다음 정리에..
{: .prompt-warning }


## 자바 메모리 모델 (JMM)
<hr />

- 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티 스레드 프로그래밍에서 스레드 간의 상호작용을 정의한다. 
- 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의다.

### happens-before

- 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다. 
- 만약 A 작업이 B 작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리 변경 사항은 B 작업에서 볼 수 있다. 
- 즉, A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.

> 메모리 가시성을 보장하는 것이다.
{: .prompt-info }

### happens-before 관계가 발생하는 경우

- 프로그램 순서 규칙
- volatile 변수 규칙
- 스레드 시작 규칙
- 스레드 종료 규칙
- 인터럽트 규칙
- 객체 생성 규칙
- 모니터 락 규칙
- 전이 규칙 (Transitivity Rule)


## 참고자료
<hr />

[김영한의 실전 자바 - 고급 1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)
