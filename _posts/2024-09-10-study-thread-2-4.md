---
title: 4 스레드 제어와 생명 주기 - 2
date: 2024-09-10 22:27:00 +0900
categories: [Study, Java-advanced1]
tags: [study, java, thread, adv1]
pin: true
---

## 스터디 git 주소
<hr />

- <https://github.com/chj-dev/java-adv1>

## 스레드 제어와 생명 주기 - 2

### 스레드가 대기하는 상태에서 스레드를 깨우고 싶다면?

- Thread.sleep() 등을 통해 스레드가 대기 상태에 있는데, 이 스레드를 급하게 깨워서 처리해야 하는 일이 있다. 
- 혹은 작업 종료를 지시하고 싶을 수도 있다.

### 인터럽트

- 이전에 배운 내용을 보면, Thread.sleep() 을 호출할 때 항상 try-catch 문을 사용했다. 여기서 catch 문에는 항상 InterruptedException 이 있었다.
- 이는 sleep() 상태 중에, 인터럽트가 발생할 수 있다는 것을 의미한다.
- 인터럽트가 발생한 스레드는 대기 상태(`WAITING`, `TIME_WAITING`)에서 깨어나 `RUNNABLE` 상태, 코드를 수행할 수 있는 상태가 된다.
- `thread.interrupt()` 와 같이 인터럽트를 발생시킬 수 있다.

### 인터럽트 상태

- 인터럽트가 적용되어 인터럽트 예외가 발생하면 해당 스레드는 RUNNABLE 상태가 되고, 인터럽트 상태값이 true 가 된다.
- 하지만 이때, 만약 catch(InterruptedException) 문으로 오류가 잡히게 되면 인터럽트 상태값은 false 로 다시 변경된다.

### 왜 인터럽트의 상태는 다시 false 로 돌아갈까?

- 자원 정리를 하는 도중에 인터럽트가 발생하면, 자원 정리에 실패한다.
- 인터럽트의 목적을 달성하면 인터럽트 상태를 다시 정상(false)으로 돌려두어야 한다.
- 아래는 똑같이 인터럽트 상태를 조회하지만, 약간의 차이가 있다.

1. Thread.currentThread().isInterrupted()
: 인터럽트 상태 변경없이 단순히 상태만 조회한다.
: 이 경우 인터럽트 상태가 true 라면, 계속해서 인터럽트가 발생하여 **자원 정리에 실패**한다.

2. Thread.interrupted()
: 인터럽트의 상태를 변경한다.
: 이 경우 인터럽트 상태가 true 라면, 인터럽트를 false 로 변경한다.
: 인터럽트 상태가 false 라면, 상태를 변경하지 않는다.

### 스레드 동시 접근

- 자세한 내용은 다음에 설명한다.

1. volatile
: 여러 스레드가 동시에 접근하는 변수는 volatile 키워드를 붙여주어야 안전하다. (thread-safe)

2. ConcurrentLinkedQueue
: 여러 스레드가 동시에 접근하는 동시성 컬렉션 (Queue)


## yield - 양보하기

- 어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정한다. 
- 그런데 특정 스레드가 바쁘지 않다면 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다.

### sleep 은 안쓰고 왜?

- sleep 은 스레드가 `RUNNABLE` 에서 `TIME_WAITING` 상태로 변경된다. 
- 그리고 대기 시간이 지나면 다시 `RUNNABLE` 상태가 된다.
- 결과적으로 대기 상태가 되면서 다른 스레드의 실행을 양보하는 건 맞다. 
하지만 이 방식은 상태가 여러번 변경되는 복잡한 과정을 거치고, 
특정 시간만큼 스레드가 실행되지 않는다는 단점이 있다.
- 양보할 스레드가 없는데 특정 시간동안 양보하는 중인 이상한 상황이 발생할 수 있다는 것이다.

### yield()

- Thread.yield() 메서드는 현재 실행중인 스레드가 자발적으로 CPU 를 양보하여 다른 스레드가 실행될 수 있도록 한다.
- 하지만 sleep 과는 다르게 계속 `RUNNABLE` 상태를 유지한다.
- 이때 운영체제에게 양보할 수 있다는 힌트를 제공할 뿐, 강제적으로 실행 순서를 지정하지는 않는다. 따라서 반드시 다른 스레드가 실행되는 것도 아니다.

### RUNNABLE 세부 상태

- 자바에서는 두 상태를 구분할 수는 없지만, RUNNABLE 상태는 아래처럼 세분화 할 수 있다.

1. Ready: 실행 대기 상태
: 스레드가 실행할 준비가 되었지만, 스케줄링 큐에서 대기 중이다.

2. Running: 실행 상태
: 스레드가 CPU 에서 실행 중이다.


## 참고자료
<hr />

[김영한의 실전 자바 - 고급 1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)
