---
title: 1 운영체제 기본
date: 2024-05-04 12:45:00 +0900
last_modified_at: 2024-06-01 14:18:00 +0900
categories: [Study, Thread]
tags: [study, java, thread]
pin: true
---

## 스터디 git 주소
<hr/>

- <https://github.com/chj-dev/Study_Concurrency>


## 섹션 1
<hr/>

### 1강, Process & Thread

**# 정리.** 

1. 프로세스   
: CPU를 할당받고 명령을 수행하고 있는 상태이자 운영체제로부터 자원을 할당받은 최소 작업 단위.
: 프로그램 A는 프로세스 1로 실행이 되고, 프로세스는 동적할당 영역인 스택과 힙, 정적할당 영역인 데이터, 코드 영역을 가짐.   
- stack: 함수 내의 지역변수 매개변수 리턴값 등 저장, 함수 호출 완료 시 소멸됨. 높은 주소 > 낮은 주소로 할당됨.   
- heap: 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소 > 높은 주소로 할당됨.   
- data: 전역변수 static 변수 등 저장, 프로그램 종료 시 소멸됨.   
- code: 사용자가 작성한 코드. CPU가 해당 명령어를 가져가서 처리함.
: 독립적인 메모리 영역을 가짐 = 독립적인 작업 수행 가능

2. 스레드
: 프로세스의 실행 단위 또는 흐름의 단위.
: 프로세스와 마찬가지로 메모리 영역을 가지고 있지만, code, data, heap 영역은 각 스레드가 공유하고, stack만 독립적으로 사용한다.
: 독립적인 스택 영역 = 독립적인 함수 호출 가능
: 운영체제의 스케쥴러에 의해 관리된다. 즉, 스레드가 CPU를 선점하여 실행될 때마다 컨텍스트 스위칭이 발생한다.

**# 질문.**   
1. 높은 주소, 낮은 주소?
2. 높고 낮음을 구분해 놓은 이유? 그냥 각각 동적으로 계속 메모리 주소를 차지하려고? 근데 그렇다기엔 Stack Overflow, Heap Overflow 라는 에러도 있는데??

> 스택은 컴파일 시에 크기가 결정된다. 메모리 할당이 따로 필요없으며, 사용한 메모리를 굳이 반납하지 않고 Stack Pointer를 이동시키며 데이터를 저장한다.
> 따라서 이미 데이터가 있으면 덮어씌운다.    
> 힙은 런타임에 크기가 결정된다. 메모리 할당/해제 작업이 필요하다.   
> 힙과 스택이 중간에 공유 라이브러리 영역을 두고 효율적으로 메모리 할당을 받기 위해서 높음>낮음 접근, 낮음>높음 접근을 한다.   
> 메모리 충돌을 방지 하기 위해 각각 다른 방향에서 접근을 한다. 같은 방향이라면 메모리들이 엉킨다.   
> 스택이나 힙(아키텍처마다 다름)이 높은 주소부터 낮은 주소로 내려가야 커널 영역에 침범하지 않는다. (커널영역 전에는 Off-Limit 영역이 있는데, 사용자가 커널에 접근할 수 없도록 할당해두는 공간이 있다.)
> 만약 침범을 했다면 Overflow 가 발생했을 것 같다.(내 생각)   
> Stack/Heap Overflow 가 발생하는 이유는 예를 들어 스택 메모리가 많이 사용되어서 다음에 저장할 포인터 위치에 저장될 메모리 공간이 부족해서, 지정된 범위를 벗어났을 때 발생한다.
> ex. 남은 스택 공간: 1MB, 저장할 스택 메모리: 1.5MB
{: .prompt-info }


### 2강, Parallel & Concurrent

**# 정리.**

1. 동시성
: 특정한 순서 없이 여러 작업이 겹치는 기간에 시작, 실행, 완료 되는 것.
: CPU가 한번에 많은 일을 처리하는 것에 중점을 두어, 작업들을 아주 빠른 시간으로 교체하면서 처리한다. (하나의 CPU가 여러 작업을 교체하면서 처리)
: 중적: CPU를 효율적으로 사용하는 것.
: 일반적으로 작업해야 할 수가 CPU 코어 수보다 많을 경우 해당된다.
: 작업 처리 방식에 대한 설계이다.

2. 병렬성
: 멀티 코어 프로세서에서 여러 작업이 동시에 실행되는 것.
: 중점: CPU가 동시에 많을 일을 수행하는 것.
: 동시성의 하위 개념으로, 스레드를 여러 CPU에 적절히 분배하여 동시적으로 실행되도록 하는 것.
: 일반적으로 작업해야 할 수가 CPU 코어 수보다 같거나 적은 경우 효율이 좋다.
: 하드웨어 계층에서 작업 수행 방식에 관한 것이다.

3. 자바의 사용 예
: ThreadPoolExecutor: 동시성과 병렬성을 적용한 처리 방식 채택


### 3강, Context Switch

**# 정리.**

1. 컨텍스트 스위칭
: 하나의 CPU 에서 여러 프로세스/스레드를 동시성으로 처리하기 위해, 다른 프로세스/스레드로 전환하는 것.   
: 1) 발생 조건   
- 실행중인 작업에서 I/O 호출이 일어났을 경우.   
- 라운드 로빈(Round Robin) 스케쥴링 등 운영체제의 CPU 알고리즘에 이해 다른 프로세스가 실행되도록 전환하는 경우.
: **Context?**   
- 프로세스 간 전환을 위해 현재 상태나 값에 대한 정보.   
- 이전에 어디까지 명령을 수행했는지? 어떤 값이 저장되어 있는지?   
- 해당 정보들은 프로세스는 PCB, 스레드는 TCB 라는 자료구조 공간에 저장된다.       
=> 컨텍스트 스위칭은 이러한 자료구조를 교체하고 캐시를 비우는 과정을 말한다.

2. PCB
: Process Control Block
: 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조.
: 프로세스의 고유 ID, 현재 상태, 현재 위치를 갖는 포인터 정보, CPU 스케줄링 정보, 프로세스 우선 순위, 다음에 실행할 명령어의 주소 등의 정보를 갖는다.
: 프로세스의 컨텍스트 스위칭은 메모리 주소와 관련하여 처리를 하기 때문에 오버헤드가 크다.

3. TCB
: Thread Control Block
: 스레드 정보를 담는 자료구조.
: 스레드의 고유 ID, Register Set (CPU 정보), PCB를 가리키는 포인터 등을 갖는다.
: 스레드가 생성될 때마다 PCB 내에서 TCB 가 생성된다.
: 스레드의 컨텍스트 스위칭은 메모리 주소 관련 추가 작업이 없어 프로세스에 비해 오버헤드가 작다 = 컨텍스트 스위칭이 빠르다.

- 스레드가 많이 생성되면 메모리 부족 현상이 발생하거나 빈번한 컨텍스트 스위칭으로 어플리케이션 성능이 저하될 수 있다.


**# 질문.**
1. 라운드 로빈?

> 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간 단위로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘. 
{: .prompt-info }


### 4강, CPU Bound & I/O Bound

**# 정리.**

**Burst**   
- 한 작업을 짧은 시간동안 집중적으로 연속해서 처리하거나 실행하는 것.

- CPU Burst
: CPU 를 연속적으로 사용하면서 명령어를 실행하는 구간.
: 프로세스의 RUNNING 상태 처리.

- I/O Burst
: 연속적으로 I/O 를 실행하는 구간.
- 프로세스의 WAITING 상태를 처리.

**결론 =>**
- 프로세스는 CPU 작업과 I/O 작업을 번갈아 처리한다.   
- 해당 작업들을 처리하는 비율은 프로세스마다 다르다.
- 위 비율을 기준으로 CPU 바운드 프로세스와 I/O 바운드 프로세스로 나눌 수 있다.

<br/>

1. CPU Bounded Process
: CPU Burst 작업이 많은 프로세스. (ex. 머신러닝, 블록체인, 동영상 편집 프로그램)
: 멀티 코어의 병렬성을 최대한 활용하여 처리 성능을 극대화하도록 운용한다 => CPU 코어 수와 스레드 수의 비율을 비슷하게 설정.

2. I/O Bounded Process
: I/O Burst 작업이 많은 프로세스. (ex. 파일, 키보드, DB, 네트워크 등 외부 연결이나 입출력 장치와 통신 작업)
: CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU가 Idle 상태가 되지 않도록 최적화된 스레드 수를 운용한다.


### 5강, 사용자 모드 & 커널 모드

**# 정리.**

1. 운영체제
: 사용자가 컴퓨터 시스템을 편하게 사용할 수 있는 환경을 제공하고, 시스템의 자원을 효율적으로 관리하는 소프트웨어 (하드웨어와 소프트웨어 간 중개자 역할 수행)
: 커널(Kernel): 운영체제의 여러 기능 중 핵심 기능을 담당하는 부분.
: 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원 보호.   
- 직접 접근하게 된다면 자원 관리가 되지 않고, 프로세스 간 데이터가 훼손됨 => 컴퓨터 시스템 전체의 오류   
- 반드시 운영체제를 통한 접근만 허용해야 함.

2. 사용자 모드 (Mode Bit = 1)
: CPU 가 명령어를 실행할 때 사용하는 모드 중 하나.
: 유저 영역에 접근 가능.
: 디스크, 메모리, 프린터 및 여러 I/O 장치들과 같은 특정 리소스에 직접 접근할 수 없다 => 필요하다면 시스템 호출(System Call)을 통해 커널모드로 전환 필요.

3. 커널 모드 (Mode Bit = 0)
: CPU 가 명령어를 실행할 때 사용하는 모드 중 하나.
: 유저 영역과 커널 영역 모두 접근 가능.
: 하드웨어 자원에 직접 접근하여 명령을 수행함.

4. 시스템 호출 (System Call)
: 커널모드에 접근하기 위한 인터페이스.
: 사용자 응용 프로그램은 커널의 기능을 사용하기 위해 시스템 콜을 요청해야 하고, 이것으로 사용자 모드와 커널 모드를 상호 전환하여 실행하게 된다.
: **I/O 처리를 위해 사용자 - 커널 모드를 번갈아 오는 것은 컨텍스트 스위칭과 관련이 있다.**

**# 질문.**
1. 사용자 - 커널 모드 전환 시 스레드도 같이 전환되어서 컨텍스트 스위칭과 관련이 있는 것인지?

> 컨텍스트 스위칭을 통해 필요한 권한과 환경을 세팅한다.   
> 컨텍스트 스위칭은 프로세스 전환(멀티 태스킹) 외에도 인터럽트 핸들링, 사용자 - 커널 모드 전환과 같이 3개로 존재한다.   
> 컨텍스트 스위칭이 길어지면 CPU는 아무 일도 하지 않는 시간(오버헤드)이 발생한다. 오버헤드가 잦아지면 성능이 떨어질 수 있다.
{: .prompt-info }


### 6강, 사용자 수준 스레드 & 커널 수준 스레드

**# 정리.**

1. 사용자 수준 스레드 (User Level Thread)
: 스레드의 유형 중 하나. 
: 스레드 라이브러리에 의해 스레드 생성/종료, 스레드 간 메세지 전달, 스레드의 스케쥴링 보관 등 모든 것을 관리한다.
: 사용자 프로그램에서 관리하며 커널은 사용자 수준 스레드에 대해 알지 못한다 = 단일 스레드 프로세스인 것처럼 관리한다.

2. 커널 수준 스레드 (Kernel Level Thread)
: 스레드의 유형 중 하나.
: OS(커널)가 스레드와 관련된 모든 작업을 관리. (PCB와 TCB 관리 및 유지)
: 커널은 커널 스레드의 모든 정보를 알고 있고, OS 스케쥴러에 의해 스케쥴링됨.
: CPU 는 OS 스케쥴러를 통해, 커널에 의해 생성된 커널 스레드의 실행만을 담당한다. = 사용자 수준 스레드가 실행되려면, 커널 수준 스레드와 매핑 필요

3. 다대일 스레드 매핑 (many to one thread mapping)
: 커널 수준 스레드 1 : 사용자 수준 스레드 N 매핑, 사용자 수준의 스레드 모델이다.
: PCB 는 커널 영역에, TCB 는 사용자 영역에서 관리한다. 
: 오버헤드가 적다.   
- 커널 개입 없이 사용자 스레드끼리의 스위칭.   
- 스케쥴링이나 동기화를 이유로 시스템 콜을 호출하지 않음.
: 단일 스레드의 프로세스 단위로, 멀티코어를 활용한 병렬처리 불가.
: 한 스레드가 Block I/O 발생 시, 모든 스레드가 Block 됨 = 프로세스 자체를 Block 하기 때문.
: 자바 초기 버전의 Green Thread 가 이 모델에 해당됨.

4. 일대일 스레드 매핑 (one to one thread mapping)
: 커널 수준 스레드 1 : 사용자 수준 스레드 1 매핑, 커널 수준의 스레드 모델이다.
: PCB 와 TCB 모두 커널 영역에서 관리한다.
: 커널이 전체 프로세스와 스레드 정보를 유지해야 하기 때문에 컨텍스트 스위칭 시 사용자 모드 > 커널 모드로 전환하여 스케쥴링 하는 등의 오버헤드가 발생한다.
: 자원이 한정되어 스레드를 무한으로 생성할 수 없다 => 스레드 풀 활용.
: 스레드 단위로 CPU 를 할당한다 = 멀티코어를 활용한 병렬 처리 가능.
: 스레드 중 한 개가 대기 상태가 되어도 다른 스레드 실행 가능 = 멀티스레드의 동시성 활용 가능.
: 자바의 Native Thread 가 이 모델에 해당됨.

5. 다대다 스레드 매핑 (many to many thread mapping)
: 커널 수준 스레드 N : 사용자 수준 스레드 M 매핑, 커널 수준 스레드의 개수는 사용자 수준 스레드의 개수보다 적거나 같음.
: PCB 와 TCB 모두 커널 영역에서 관리한다.
: 다대일, 일대일 모델의 단점을 어느 정도 해결한 모델 = 필요한 만큼 많은 사용자 수준 스레드 생성 가능, 커널 수준 스레드가 멀티 프로세서에서 병렬로 수행될 수 있다.
: 사용자 수준 스레드가 I/O 시스템 콜을 발생시켰을 때, 커널이 다른 스레드의 수행을 스케쥴할 수 있다.


## 참고자료
[인프런 자바-동시성-프로그래밍-리액티브-part1](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94-%EB%8F%99%EC%8B%9C%EC%84%B1-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-part1/dashboard)
