---
title: 10 CAS 동기화와 원자적 연산
date: 2024-11-24 15:32:00 +0900
categories: [Study, Java-advanced1]
tags: [study, java, thread, adv1]
pin: true
---

## 스터디 git 주소
<hr />

- <https://github.com/chj-dev/java-adv1>


## 원자적 연산 (atomic operation)

- 더 이상 나눌 수 없는 단위로 수행된다는 것으로, 컴퓨터 과학에서 사용하는 용어이다.
- 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가진다는 것을 의미한다.
- **원자적 연산이 아닌 경우 멀티 스레드 환경에서 예상치 못한 오류가 발생한다. 따라서 해당 연산이 있을 경우 안전한 임계 영역을 만들어야 한다.**

### 원자적 연산의 예시

- `int i = 0;`
  - 원자적 연산이다.
  1. i 변수에 1을 대입한다.
- `i = i + 1;`
  - 원자적 연산이 아니다.
  1. 오른쪽 i의 값을 읽는다. i는 0이다.
  2. 읽은 0에 1을 더해서 1을 만든다.
  3. 1의 값을 왼쪽 i 변수에 대입한다.
- `i++;`
  - `i = i + 1;` 을 축약한 문법이기 때문에 원자적 연산이 아니다.

### volatile 을 적용하면?

- volatile 은 캐시 메모리와 메인 메모리가 동기화되지 않는 문제를 해결할 뿐이다.
- 메인 메모리를 직접 읽어도 멀티 스레드 환경에선 여전히 원자적 연산이 되지 않는다.
- 연산 자체가 나누어져 있기 때문이다.

### AtomicXXX (ex. AtomicInteger)

- synchronized 처럼 멀티 스레드 환경에서 사용할 수 있게 안전한 값 증가, 감소 연산을 제공한다.
- 즉, 원자적 연산을 만들어낸다.

### 성능은 어떨까?

- **Basic**
  - ex. `i++;`
  - 가장 빠르다.
  - CPU 캐시를 적극 사용한다.
  - 임계 영역이 없기 때문에 멀티 스레드 환경에서는 사용할 수 없다. 
  - 단일 스레드일 경우에 가장 효율적이다.
- **Volatile**
  - ex. `volatile int value;`
  - 메인 메모리를 사용한다.
  - 임계 영역이 없기 때문에 멀티 스레드 환경에서는 사용할 수 없다.
  - 단일 스레드 환경에서 사용하기엔 Basic 방법 보다 느리다.
- **Synchronized**
  - ex. `synchronized 블록 사용`
  - 안전한 임계 영역으로 멀티 스레드 환경에서 사용할 수 있다.
  - 하지만 Atomic 방법 보다 느리다.
- **Atomic**
  - ex. `AtomicInteger atomicInteger = new AtomicInteger(0);`
  - 멀티 스레드 환경에서 사용할 수 있다.
  - synchronized, Lock(ReentrantLock) 보다 1.5~2배 정도 빠르다.


- 왜 AtomicInteger 가 더 빠를까? 
- AtomicInteger 가 제공하는 `incrementAndGet()` 메서드는 **락을 사용하지 않고 원자적 연산**을 만들어낸다.
- 어떻게?

## CAS (Compare-And-Swap/Set) 연산

- 락을 사용하지 않기 때문에 락 프리(lock-free) 기법이라고도 한다.
- 락을 완전히 대체하는 것은 아니고 **작은 단위의 일부 영역에 적용**할 수 있다.

### compareAndSet(0, 1)

- 현재 값이 0이면 1로 변경하라는 단순한 메서드 이다.
- 값이 변경되면 true, 변경되지 않으면 false 를 반환한다.
- **이 메서드는 원자적으로 실행**된다.

> 해당 메서드가 제공하는 기능이 바로 CAS 연산이다.
{: .prompt-info }

### CPU 하드웨어가 지원한다

- CAS 연산은 원자적이지 않은 두 개의 연산을 **CPU 하드웨어**가 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.
- 따라서 중간에 다른 스레드가 개입하지 못한다.

### 하지만 어떻게 락을 일부 대체하는 걸까?

- 두 스레드가 동시에 실행되면서 문제가 발생하는 상황을 스레드가 충돌했다고 표현한다.
- **CAS 연산은 충돌이 발생할 때마다 반복해서 다시 시도**하므로, 락 없이 데이터를 변경할 수 있다.
- 락 획득을 위해 스레드가 대기하지 않기 때문에 대기 시간과 오버헤드가 줄어든다.
- 하지만 충돌이 빈번하게 발생하는 환경에서는 CPU 자원을 많이 소모하게 되기 때문에 성능에 문제가 될 수 있다.

### CAS vs Lock

1. 락(Lock) 방식
: 비관적(pessimistic) 접근법
: 데이터에 접근하기 전에 항상 락 획득
: 다른 스레드의 접근을 막음
: `항상 다른 스레드가 방해할 것이다` 라고 가정

2. CAS(Campare-And-Swap) 방식
: 낙관적(optimistic) 접근법
: 락을 사용하지 않고 데이터에 바로 접근
: 충돌이 발생하면 재시도
: `충돌이 거의 없을 것이다` 라고 가정

> 간단한 CPU 연산일 경우 락보다는 CAS 사용이 효과적이다.
{: .prompt-info }


### SpinLock

- CAS 를 사용하여 **간단한 락을 구현**할 수도 있다.
- 락 사용 여부를 확인하고, 락의 값을 변경하는 부분을 CAS 방식을 통해 묶어버리는 것이다.
```java
private final AtomicBoolean lock = new AtomicBoolean(false);
...
  //락 획득 시도
  while (!lock.compareAndSet(false, true)) {
    //락 획득 실패 - 스핀 대기(spin-wait / busy-wait)
  }
  //락 획득 완료
```

- 하지만 위 방식에도 단점이 있다.

### CAS 단점

- while 문을 반복하기 때문에, 락을 기다리는 스레드가 CPU 를 계속 사용하면서 대기하는 것이다.
- BLOCKED 나 WAITING 상태로 대기하는 것이 아니라 RUNNABLE 상태이기 때문이다.


- 따라서 매우 짧은 연산을 할 때만 사용해야 한다. 
- DB 결과를 기다린다거나, 다른 서버의 요청을 기다리는 것처럼 오래 대기하는 작업에 사용하면 CPU 를 계속 사용하기 때문에 오버헤드가 발생할 수 있다.


## CAS, Lock 장단점 비교

### CAS

- **장점**
  - **낙관적 동기화**: 스레드 충돌이 자주 발생하지 않을 것이라 가정. 충돌이 적은 환경에서 높은 성능.
  - **락 프리(Lock-Free)**: 락을 획득하기 위해 대기하는 시간이 없어서 스레드가 블로킹되지 않는다.
- **단점**
  - **충돌이 빈번한 경우**: 루프를 돌며 계속 재시도 하기 때문에 CPU 자원을 많이 사용하고, 오버헤드가 발생할 수 있다.
  - **스핀락과 유사한 오버헤드**: 충돌 빈도가 높을 수록 성능 저하가 발생 현상이 두드러진다.

### 동기화 락

- **장점**
  - **충돌 관리**: 하나의 스레드만 리소스에 접근하므로 충돌이 발생하지 않는다.
  - **안정성**: 복잡한 상황에서도 락은 일관성 있는 동작을 보장한다.
  - **스레드 대기**: 대기하는 스레드는 CPU 를 거의 사용하지 않는다.
- **단점**
  - **락 획득 대기 시간**: 락 획득을 위한 대기 시간이 길어질 수 있다.
  - **컨텍스트 스위칭 오버헤드**: 락 획득을 대기하는 시점과 획득하는 시점에 스레드의 상태가 변경된다. 이때 컨텍스트 스위칭이 발생할 수 있어, 이로 인해 오버헤드가 증가한다.


## 참고자료
<hr />

[김영한의 실전 자바 - 고급 1편](https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%8B%A4%EC%A0%84-%EC%9E%90%EB%B0%94-%EA%B3%A0%EA%B8%89-1/dashboard)
